library(testthat)
library(rIACI)
library(reticulate)

# Python virtual environment
test_that("Set up Python virtual environment", {
  skip_if_not_installed("reticulate")

  if (!py_available(initialize = FALSE)) {
    skip("No Python available in this environment, skipping Python tests.")
  }

  env_dir <- file.path(tempdir(), "test_py_env")

  if (!dir.exists(env_dir)) {
    message("Creating Python virtual environment at: ", env_dir)
    virtualenv_create(env_dir)
    message("Installing Python packages...")
    py_install(
      packages = c("xarray", "pandas", "numpy", "netCDF4", "dask"),
      envname  = env_dir
    )
  }

  use_virtualenv(env_dir, required = TRUE)

  xarray <- import("xarray", convert = FALSE)
  expect_true(!is.null(xarray), "xarray should be available after installation.")
})

### 1: download_data
test_that("Integrated Test: download_data", {
  # Define parameters for the download request
  start_year <- 2020
  end_year <- 2020
  start_month <- 1
  end_month <- 1
  variables <- c("2m_temperature", "total_precipitation")
  dataset <- "reanalysis-era5-land"
  area <- c(44, -10, 36, 4)

  # Create a temporary directory for downloaded data
  output_dir <- tempfile("cds_data_")
  dir.create(output_dir)

  # Retrieve ECMWF credentials from environment variables
  user_id <- Sys.getenv("ECMWF_USER_ID")
  user_key <- Sys.getenv("ECMWF_USER_KEY")

  # Skip the test if credentials are not set
  if (user_id == "" || user_key == "") {
    skip("ECMWF_USER_ID or ECMWF_USER_KEY not set, skipping download test")
  }

  # Call the download_data function to request data download
  download_data(
    start_year = start_year,
    end_year = end_year,
    start_month = start_month,
    end_month = end_month,
    variables = variables,
    dataset = dataset,
    area = area,
    output_dir = output_dir,
    user_id = user_id,
    user_key = user_key,
    max_retries = 1,
    retry_delay = 0,
    timeout = 7200
  )

  # Check that the downloaded file exists (either a .zip or .nc file)
  expected_nc  <- file.path(output_dir, "2020_01.nc")

  expect_true(file.exists(expected_nc))
})

### 2: process_data
test_that("Integrated Test: process_data", {
  # Locate the test NetCDF file directory in the package's inst/extdata folder
  input_dir <- system.file("extdata", "testdata", package = "rIACI")
  expect_true(nchar(input_dir) > 0, info = "Cannot locate the 'processtest' directory in extdata")

  # Create a temporary directory for processed data output
  output_dir <- tempfile("processed_data_")
  dir.create(output_dir)

  # Call the process_data function to process the test data
  process_data(input_dir = input_dir, output_dir = output_dir, save_merged = FALSE)

  # Check that the processed data output directory contains files
  output_files <- list.files(output_dir)
  expect_gt(length(output_files), 0)
})

### 3: export_data_to_csv, output_all (monthly and seasonal), and csv_to_netcdf
test_that("Integrated test: export_data_to_csv, output_all (monthly & seasonal), and csv_to_netcdf", {
  ## --- Step 3: Export Data to CSV ---
  # Use system.file() to locate the NetCDF file stored in inst/extdata/subset.nc
  netcdf_file <- system.file("extdata", "subset.nc", package = "rIACI")
  expect_true(file.exists(netcdf_file), info = "Processed NetCDF file does not exist. Check the path.")

  # Create a temporary directory to store CSV files generated by export_data_to_csv.
  csv_output_dir <- tempfile("csv_output")
  dir.create(csv_output_dir)

  # Convert the NetCDF file into CSV files.
  expect_error(
    export_data_to_csv(nc_file = netcdf_file, output_dir = csv_output_dir),
    NA
  )

  # Verify CSV files were created.
  csv_files <- list.files(csv_output_dir, pattern = "\\.csv$", full.names = TRUE)
  expect_true(length(csv_files) > 0, info = "No CSV files were generated by export_data_to_csv.")

  # Check that each CSV contains the required columns.
  required_cols <- c("TMAX", "TMIN", "PRCP", "WP", "time")
  for (file in csv_files) {
    df <- read.csv(file)
    missing_cols <- setdiff(required_cols, names(df))
    expect_true(length(missing_cols) == 0,
                info = paste("File", basename(file), "is missing columns:", paste(missing_cols, collapse = ", ")))
  }

  ## --- Step 4: Calculate IACI and Output Monthly Results ---
  # Use the CSV files generated above as input for output_all.
  input_dir <- csv_output_dir

  # Construct sea level data (generate a blank series for the full time range).
  sea_dates <- seq(as.Date("1960-01-01"), as.Date("2023-12-01"), by = "month")
  sea_dates <- format(sea_dates, "%Y-%m")
  sea_values <- rep(NA, length(sea_dates))
  si <- sea_input(Date = sea_dates, Value = sea_values)

  # Create a temporary directory for IACI monthly output results.
  monthly_output_dir_parent <- tempfile("iaci_monthly_results")

  expect_error(
    output_all(
      si = si,
      input_dir = input_dir,
      output_dir = monthly_output_dir_parent,
      freq = "monthly",
      base.range = c(1961, 1990),
      time.span = c(1961, 2023)
    ),
    NA
  )

  # Verify that the "monthly" directory exists and contains CSV files.
  monthly_output_dir <- file.path(monthly_output_dir_parent, "monthly")
  expect_true(dir.exists(monthly_output_dir), info = "output_all did not create a 'monthly' directory.")
  monthly_files <- list.files(monthly_output_dir, pattern = "\\.csv$")
  expect_true(length(monthly_files) > 0, info = "No CSV files generated in the monthly output directory.")

  # Check that one sample monthly output file has an IACI column.
  sample_monthly <- read.csv(file.path(monthly_output_dir, monthly_files[1]))
  expect_true("IACI" %in% names(sample_monthly), info = "Monthly output CSV file does not contain the IACI column.")

  ## --- Step 4b: Calculate IACI and Output Seasonal Results ---
  # Create a temporary directory for IACI seasonal output results.
  seasonal_output_dir_parent <- tempfile("iaci_seasonal_results")

  expect_error(
    output_all(
      si = si,
      input_dir = input_dir,
      output_dir = seasonal_output_dir_parent,
      freq = "seasonal",
      base.range = c(1961, 1990),
      time.span = c(1961, 2023)
    ),
    NA
  )

  # Verify that the "seasonal" directory exists and contains CSV files.
  seasonal_output_dir <- file.path(seasonal_output_dir_parent, "seasonal")
  expect_true(dir.exists(seasonal_output_dir), info = "output_all did not create a 'seasonal' directory.")
  seasonal_files <- list.files(seasonal_output_dir, pattern = "\\.csv$")
  expect_true(length(seasonal_files) > 0, info = "No CSV files generated in the seasonal output directory.")

  # Check that one sample seasonal output file has an IACI column.
  sample_seasonal <- read.csv(file.path(seasonal_output_dir, seasonal_files[1]))
  expect_true("IACI" %in% names(sample_seasonal), info = "Seasonal output CSV file does not contain the IACI column.")

  ## --- Step 5: Merge CSVs into NetCDF ---
  # Use the monthly output CSVs as input for csv_to_netcdf.
  merged_netcdf <- tempfile(fileext = ".nc")
  expect_error(
    csv_to_netcdf(csv_dir = monthly_output_dir, output_file = merged_netcdf, freq = "monthly"),
    NA
  )

  # Check that the merged NetCDF file was created.
  expect_true(file.exists(merged_netcdf), info = "csv_to_netcdf did not generate the merged NetCDF file.")
})
